9장 유효성 검사

######1. 유효성 검사 개요

1) 유효성 검사란
- 폼 페이지 -> 서버로 전송될 때, 유효한 데이터가 전송되는지 검사
- 유효성 검사 필수적인 폼 데이터
입력 데이터 null
날짜, 이메일 형식
나이를 숫자로 입력
입력 데이터의 제한 길이
로그인 인증 시 아이디, 패스워드 유효
회원가입 시 입력 아이디 중복

2) 유효성 검사 설정
- @Valid 애너테이션 이용
- 의존 라이브러리 등록 : bulid.gradle 파일에 validation 의존 라이브러리 추가
- @Valid 설정 : 요청 처리 메서드에 @Valid 선언


3) 유효성 검사 유형
- Bean Validation : 도메인 클래스 멤버 변수 -> 제약사항 애너테이션 선언
- ConstraintValidator : 도메인 클래스 멤버 변수 -> 사용자 정의 애너테이션 선언
- Validator : 모든 계층 -> Validation 인터페이스


######2. 유효성 검사

1) Bean Validation
- 도메인 클래스 멤버 변수(필드) -> 유효성 검사 제약사항 애너테이션
- 유효성 검사 처리 과정
제약사항 애너테이션 선언
유효성 검사 실행
오류 메세지 출력

- 기본 메세지 : hibemate-validator-xxx.jar 라이브러리 기본 메세지 제공
- 사용자 정의 메세지 : message 속성 값에 오류 메세지 직접 정의

2) ConstraintValidator
- 프로퍼티 값 중복 확인 가능
- 사용자 정의 애너테이션 정의하는 것 제외하고 Bean Validation 유효성 검사와 동일
- 유효성 검사 처리 과정
사용자 정의 애너테이션 선언 (@interface,  ConstraintValidator 구현체)
유효성 검사
오류 메세지

- 사용자 정의 애너테이션 생성 (@Constraint, @Retention, @Target)
- 구현체 생성 (ConstraintValidator 구현체 -> 유효성 검사 클래스
			initialize() -> 사용자 정의 애너테이션 정보 초기화
			isValid() -> 유효성 검사 로직 수행)

3) Validator
- Validator 인터페이스
- 유효성 검사 처리 과정
Validator 인터페이스 구현체 생성
@InitBinder 메서드 추가
유효성 검사
오류 메시지 출력

---------------------------------------------------------------------------------------------------------


###빈칸 문제 
1. 애플리케이션의 모든 계층에서 사용할 수 있는 유효성 검사 방식은?
2. 사용자 정의 애너테이션을 만들 때 반드시 사용해야 하는 3가지 구성요소는?
3. 제약사항 애너테이션의 기본 메세지 중에서 비어 있을 수 없다는 의미를 갖는 것은?
4. WebDataBinder 객체를 사용하여 Validator 인터페이스 구현체를 설정하는 애너테이션은?
5. 도메인 클래스의 멤버 변수에 제약사항 애너테이션을 선언하여 유효성 검사하는 방식은?

답: 
1. Validator 인터페이스 구현체 방식
2. @Constraint, @Retention, @Target
3. @NotEmpty
4. @InitBinder
5. Bean Validation


###코드 문제
1. 
// controller
@PostMapping
	public String submit(_____________ @ModelAttribute Product product, BindingResult bindingResult){		
		if(bindingResult.hasErrors()) 	
			return "viewPage01";    
		return "viewPage01_result";
	}

2. 
// controller
@Controller
@RequestMapping("/exam04")
public class Example04Controller {	

	 @Autowired
	private PersonValidator personValidator;
		 
	@GetMapping
	public String showForm(Model model) {
		model.addAttribute("person", new Person());
		return "viewPage04";
	}

	@PostMapping
	public String submit(@Valid @ModelAttribute Person person,BindingResult bindingResult)		{
		
		//personValidator.validate(person, bindingResult);
		
		if (bindingResult.hasErrors()) 
			return "viewPage04";
	
		return "viewPage04_result";
	}

	 _____________
	    protected void initBinder(WebDataBinder binder) {
	        binder.setValidator(personValidator);
	    }
}

답: 
1. @Valid 
2. @InitBinder

